CREATE VIEW [reporting].[HESS_CREW_CONSISTENCY_BASE_VW] AS 

/* ------------------ BEGIN CODE BLOCK  ------------------ */
WITH __HESS_RIGS__ AS (
    SELECT 
        ASSET_NUM AS RIG
    FROM DBO.MDM_ASSETS 
    WHERE ASSET_CLASS = 'RIG' AND CUSTOMER LIKE '%HESS%' AND [STATUS] NOT IN ('RET', 'SALV')
)

, __LABOR__ AS (
    /* GRAB THE EINS FROM THE LABOR TABLE */
    SELECT DISTINCT 
        L.ASSET_NUMBER AS RIG,
        FORMAT(L.WORK_DATE, 'MM-dd-yyyy') AS WORK_DATE,
        L.EMPLOYEE_ID AS EIN,
        SUM(L.DURATION  ) AS DURATION
    FROM DBO.LABORINCREMENTAL2 L
    INNER JOIN __HESS_RIGS__ R ON L.ASSET_NUMBER = R.RIG 
    WHERE L.CUSTOMER_ID = '000160' AND WORK_DATE > '2024-12-01' AND ASSET_NUMBER NOT LIKE 'L%'
    GROUP BY ASSET_NUMBER, WORK_DATE, EMPLOYEE_ID 
)

/* ------  THIS SECTION CREATES AN HISTORICAL RECORD FOR EACH EMPLOYEE THAT WORKS ON A HESS CREW ------ */
, __BASE_ITEMS__ AS (
    /* GET CORE ACTIONS FROM ADP TABLE TO FORM A FILTER FOR ONLY EVALUATING EMPLOYEES THAT WERE ACTIVE IN 2023 FORWARD */
    SELECT 
        EMPLOYEEID AS EIN,
        EFFECTIVEDATE,
        OrginalDateOfHire,
        [ACTION] AS HR_ACTION,
        EMPLOYEESTATUS,
        ROW_NUMBER() OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE ASC, EMPLOYEESTATUS ASC) AS ROWNUMBER 
    FROM DBO.ADP_TRANSACTIONS A 
    WHERE LEFT(EMPLOYEEID,4)  <> '9999' -- THE IS DESIGNATED FOR CONTRACTORS WHO NEED TO ACCESS OUR COMPANY SYSTEMS WITH AN EIN 
)

, __ACTIVE_TERM__ AS (
    /* CREATE A START AND END DATE FOR THE CORE ACTIVE/ TERM STATUS FIELDS */
    SELECT 
        EIN,
        CASE 
            WHEN ROWNUMBER = 1 THEN ORGINALDATEOFHIRE 
            WHEN ROWNUMBER <> 1 THEN EFFECTIVEDATE 
            END AS START_DT,
        CASE    
            WHEN LEAD(EFFECTIVEDATE) OVER (PARTITION BY EIN ORDER BY ROWNUMBER) IS NULL THEN '9999-12-31'
            ELSE LEAD(EFFECTIVEDATE) OVER (PARTITION BY EIN ORDER BY ROWNUMBER) 
            END AS END_DT,
        EMPLOYEESTATUS
    FROM __BASE_ITEMS__
)

, __FILTER__ AS (
    /* GET A LIST OF EIN'S THAT WERE ACTIVELY EMPLOYEED WITH KEY ENERGY IN 2025 */
    SELECT DISTINCT 
        EIN
    FROM __ACTIVE_TERM__ 
    WHERE EMPLOYEESTATUS IN ('A','L') AND END_DT > '2023-12-31'
)

, __ADP__ AS (
    SELECT 
        A.*,
        ROW_NUMBER() OVER (PARTITION BY EIN ORDER BY EFFECTIVEDATE ASC, ACTION_STATUS_ORDER ASC) AS ROWNUMBER 
    FROM (
        SELECT 
            EMPLOYEEID AS EIN,
            [ACTION]AS HR_ACTION,
            EFFECTIVEDATE,
            EMPLOYEESTATUS,
            CASE 
                WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) AND 
                    EMPLOYEESTATUS = 'A' AND LEAD(EMPLOYEESTATUS) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) = 'L' AND 
                    [ACTION] = 'RFL' 
                    THEN 1 -- NEED TO ORDER THE 'L' BEFORE THE 'A' WHEN THEY APPEAR IN SAME DAY AND SOMEONE RETURNS FROM LEAVE 
                WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) AND 
                    EMPLOYEESTATUS = 'T' AND LEAD(EMPLOYEESTATUS) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) = 'A' 
                    THEN 2 --GENERALLY YOU ARE NOT ACTIVE AFTER YOU TERM IN THE SAME DAY
                ELSE 0 -- ORDER BY EFFECTIVE DATE WORKS HERE
                END AS ACTION_STATUS_ORDER,
            JOBTITLE,
            LASTDATEOFHIRE AS LAST_HIRE_DT,
            ORGINALDATEOFHIRE AS ORIGINAL_HIRE_DT,
            REASONCODE
        FROM __FILTER__ E 
        LEFT JOIN DBO.ADP_TRANSACTIONS A ON (E.EIN = A.EMPLOYEEID)
        ) A 
    
)

, __ADD_BEGIN_END_DATES__ AS (
    /* ADD BEGINNING AND ENDING DATES FOR EACH CHANGE IN THE ADP TABLE */
    SELECT 
        EIN,
        /* BEGINING DATES */
        CASE 
            WHEN ROWNUMBER = 1 THEN ORIGINAL_HIRE_DT
            ELSE EFFECTIVEDATE 
            END AS START_DT, 
        CASE 
            WHEN HR_ACTION = 'TER' THEN EFFECTIVEDATE
            WHEN HR_ACTION <> 'TER' AND ROWNUMBER = MAX(ROWNUMBER) OVER (PARTITION BY EIN) THEN '9999-12-31'
            WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE)  OVER (PARTITION BY EIN ORDER BY ROWNUMBER) THEN EFFECTIVEDATE 
            ELSE DATEADD(D, -1, LEAD(EFFECTIVEDATE)  OVER (PARTITION BY EIN ORDER BY ROWNUMBER)) --BACK OFF ONE DAY SO THAT END DATES DONT CONFLICT WITH START DATES
            END AS END_DT,
        HR_ACTION,
        REASONCODE,
        ROWNUMBER 
    FROM __ADP__ 
)

, __CREW__ AS (
    /* ASSOCIATE EIN START AND END DATES WITH THE EMPLOYEE STATUS AND JOB TITLE */
    SELECT 
        B.EIN,
        B.START_DT,
        B.END_DT, 
        CASE 
            WHEN (A.HR_ACTION = 'TER' AND A.REASONCODE = 'DEA') THEN 'D' ELSE A.EMPLOYEESTATUS END AS EMPLOYEESTATUS,
        A.JOBTITLE
    FROM __ADD_BEGIN_END_DATES__ B 
    LEFT JOIN __ADP__ A ON B.EIN = A.EIN AND B.ROWNUMBER = A.ROWNUMBER 
)


/* ------ END OF CREW SECTIONS ------ */


/* CREATE FINAL EMPLOYEE/ CREW TABLE TO ASSOCIATE RIG, WORK DAY AND JOBTITLES */
, __CREW_RIG__ AS (
SELECT DISTINCT 
    L.EIN,
    L.DURATION,
    C.JOBTITLE,
    CASE -- THIS MAY OPEN UP TO ADDITIONAL JOB TITLES
        WHEN C.JOBTITLE LIKE('%Floorhand%') THEN 'FLR'
        WHEN C.JOBTITLE LIKE('%Relief Operator%') THEN 'RELOP'
        WHEN C.JOBTITLE LIKE('%Rig Operator%') THEN 'RGO'
        WHEN C.JOBTITLE LIKE('%Derrickhand%') THEN 'DERR' 
        WHEN C.JOBTITLE LIKE('%Supervisor%') THEN 'SUPR'  -- KEY HR HAS A LOT OF CODES FOR SUPERVISORS, THIS ONE IS FOR THIS REPORT ONLY
        END AS JOB_CODE,
    CASE 
        WHEN C.EMPLOYEESTATUS <>'T' THEN '' ELSE FORMAT(END_DT, 'MM-dd-yyyy') END AS TERM_DATE,  -- CONVERT TO TEXT OTHERWISE TSQL CONVERTED TO 1900-01-01
    L.RIG,
    L.WORK_DATE,
    LAG(L.WORK_DATE) OVER (PARTITION BY L.EIN ORDER BY L.WORK_DATE) AS PREVIOUS_WORK_DATE,
    ROW_NUMBER() OVER (PARTITION BY L.EIN, L.WORK_DATE ORDER BY L.WORK_DATE, L.RIG) AS ROW_COUNT
FROM __LABOR__ AS L
LEFT JOIN __CREW__ AS C ON (L.EIN = C.EIN AND (WORK_DATE >= START_DT AND WORK_DATE <= END_DT))
)

SELECT 
    EIN,
    JOBTITLE,
    JOB_CODE,
    DURATION,
    WORK_DATE,
    PREVIOUS_WORK_DATE,
    TERM_DATE,
    RIG,
    CASE 
        WHEN MAX(ROW_COUNT) OVER (PARTITION BY EIN, WORK_DATE) = 1 -- ONLY WORKED ON A SINGLE RIG THAT DAY
        THEN  LAG(RIG) OVER (PARTITION BY EIN ORDER BY WORK_DATE)
        ELSE 
            /*** THIS SECTION USES LOGIC TO TRY AND TEASE OUT THE THE CORRECT ORDER OF RIGS WHEN SOMEONE WORKS ON MORE THAN A SINGLE RIG IN A DAY */
            CASE 
                WHEN LAG(RIG) OVER (PARTITION BY EIN ORDER BY WORK_DATE, RIG) <> RIG 
                THEN 
                    CASE 
                        WHEN LAG(RIG,2) OVER (PARTITION BY EIN ORDER BY WORK_DATE, RIG)  <> RIG -- THIS MEANS CREW MEMBER CHANGED RIGS THAT DAY
                        THEN ''
                        ELSE LAG(RIG,2) OVER (PARTITION BY EIN ORDER BY WORK_DATE, RIG)
                        END 
                ELSE LAG(RIG) OVER (PARTITION BY EIN ORDER BY WORK_DATE, RIG)
                END 
        END AS PREVIOUS_RIG,
    MAX(ROW_COUNT) OVER (PARTITION BY EIN, WORK_DATE) AS DAILY_RIGS_WORKED
FROM __CREW_RIG__ 
 
;
GO

