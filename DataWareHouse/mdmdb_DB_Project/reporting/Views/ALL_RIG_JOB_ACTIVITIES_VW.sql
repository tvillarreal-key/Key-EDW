CREATE VIEW [reporting].[ALL_RIG_JOB_ACTIVITIES_VW] AS 

WITH SWINGRIGS AS (
    /* FIND THE RIG AND JOB NUMBER FOR THE SWING RIGS AND/OR THE SERVICE RIG THAT REPLACED THE SWING RIG -- THIS IS FOR HESS ONLY AS OF SEPT 2024*/
    SELECT 
        FORMAT(CONVERT(INT, ASSET_ID),'0000000') AS RIG,
        JOB_ID AS JOBNUMBER,
        JT_DESCRIPTION AS JOBTYPE,
        START_TIME AS JOBSTARTTIME,
        END_TIME AS JOBENDTIME,
        TRIM(
            LEFT(CUSTOMER_JOB_ID, CHARINDEX('-',CUSTOMER_JOB_ID, 1)-1)
            ) AS SWING_RIG,
        TRIM(
            RIGHT(CUSTOMER_JOB_ID, LEN(CUSTOMER_JOB_ID)-CHARINDEX('-',CUSTOMER_JOB_ID, 1))
            ) AS SWING_JOBNUMBER
    FROM DBO.KEYVIEW_JOB 
    WHERE CU_ORG_UNIT LIKE '%Hess%'  AND CUSTOMER_JOB_ID LIKE '%-%' 
)

, ACTIVITIES AS (
    /* GET ALL RIG ACTIVITIES */
    SELECT
        CASE  -- CREATE CUSTOMER COLUMN
            WHEN CHARINDEX('/', TRIM('/' FROM CUSTOMERORGUNIT)) = 0 THEN TRIM('/' FROM CUSTOMERORGUNIT)
            ELSE LEFT(TRIM('/' FROM CUSTOMERORGUNIT), CHARINDEX('/', TRIM('/' FROM CUSTOMERORGUNIT)) - 1) 
            END AS CUSTOMER,
        CASE  -- USE ANY ADDITIONAL CUSTOMER INFORMATION AS A "CUSTOMER_DIVISION"
            WHEN CHARINDEX('/', TRIM('/' FROM CUSTOMERORGUNIT)) = 0 THEN ''
            ELSE RIGHT(TRIM('/' FROM CUSTOMERORGUNIT), LEN(TRIM('/' FROM CUSTOMERORGUNIT)) - CHARINDEX('/', TRIM('/' FROM CUSTOMERORGUNIT))) 
            END AS CUSTOMER_DIVISION,
        /* TAKE INTO ACCOUNT ANY HESS SWING RIGS */
        CASE WHEN A.JOBNUMBER = S.JOBNUMBER THEN S.SWING_JOBNUMBER ELSE A.JOBNUMBER END AS JOBNUMBER, -- DEAL WITH HESS SWING RIGS
        CASE WHEN FORMAT(CONVERT(INT,A.RIG),'0000000') = S.RIG THEN S.SWING_RIG ELSE FORMAT(CONVERT(INT,A.RIG),'0000000') END AS RIG,
        CASE WHEN A.JOBNUMBER = J.SWING_JOBNUMBER THEN J.JOBTYPE ELSE A.JOBTYPE END AS JOBTYPE,
        CASE WHEN A.JOBNUMBER = J.SWING_JOBNUMBER THEN J.JOBSTARTTIME ELSE A.JOBSTARTTIME END AS JOBSTARTTIME,
        CASE 
            WHEN A.JOBNUMBER = J.SWING_JOBNUMBER AND CONVERT(TIME,J.JOBENDTIME) = '00:00:00' THEN DATEADD(S,-1,J.JOBENDTIME) 
            WHEN A.JOBNUMBER = J.SWING_JOBNUMBER THEN J.JOBENDTIME
            WHEN CONVERT(TIME,A.JOBENDTIME) = '00:00:00' THEN DATEADD(S,-1,A.JOBENDTIME) -- JOB CROSS MIDNIGHT, NEED TO KEEP IT IN THE SAME DAY - THIS IS REALLY FOR JOBS ENDING LAST DAY OF MONTH
            ELSE A.JOBENDTIME END AS JOBENDTIME,
        WELL_NAME,
        WORKINGDEPTH,
        WELLBORECONFIG,
        WORKTYPE,
        ACTIVITY_NUMBER,
        ACTIVITYDESCRIPTION,
        ACTIVITY_DESCRIPTION,
        ACTIVITYSTARTTIME,
        CASE 
            WHEN CONVERT(TIME,ACTIVITYENDTIME) = '00:00:00' THEN DATEADD(S,-1, ACTIVITYENDTIME) --ACTIVITY CROSSED MIDNIGHT, NEED TO KEEP IN SAME DAY
            ELSE ACTIVITYENDTIME END AS ACTIVITYENDTIME, 
        DURATIONMINUTES
    FROM DBO.KEYVIEW_ACTIVITIES2 A 
    LEFT JOIN SWINGRIGS S ON (A.JOBNUMBER = S.JOBNUMBER)
    LEFT JOIN SWINGRIGS J ON (A.JOBNUMBER = J.SWING_JOBNUMBER)
    WHERE (A.JOBENDTIME > EOMONTH(DATEADD(M,-14,GETDATE())) OR A.JOBENDTIME IS NULL) AND 
        ACTIVITYENDTIME IS NOT NULL AND -- 13 MONTH LOOKBACK OR OPEN JOBS
        CUSTOMERORGUNIT <> '////' -- THESE APPEAR TO BE TEST CASES WITH RIG '6666'
)

/* CALCULATE THE FIRST RIG UP AND LAST RIG DOWN PER JOB */
, RIGUP AS (
    SELECT 
        JOBNUMBER,
        MIN(ACTIVITYSTARTTIME) AS RUSU
    FROM ACTIVITIES
    WHERE ACTIVITY_DESCRIPTION = 'RUSU'
    GROUP BY JOBNUMBER
)

, RIGDOWN AS (
    SELECT 
        JOBNUMBER,
        MAX(ACTIVITYENDTIME) AS RDSU
    FROM ACTIVITIES
    WHERE ACTIVITY_DESCRIPTION = 'RDSU'
    GROUP BY JOBNUMBER

)


, LAG_LEAD_ACTIVITIES AS (
    /* LAG LOOKS BACK AND LEAD LOOKS FORWARD, THIS ALLOWS US TO SEE IF A JOB IS MISISNG A RIG UP, OR IF A RIG UP AND RIG DOWN ARE IN THE WRONG ORDER */
    SELECT 
        JOBNUMBER,
        ACTIVITY_NUMBER,
        ACTIVITYSTARTTIME,
        LAG(ACTIVITY_DESCRIPTION, 1) OVER (PARTITION BY JOBNUMBER ORDER BY ACTIVITYSTARTTIME) AS LAG_ACTIVITY,
        ACTIVITY_DESCRIPTION AS ACTIVITY,
        LEAD(ACTIVITY_DESCRIPTION, 1) OVER (PARTITION BY JOBNUMBER ORDER BY ACTIVITYSTARTTIME) AS LEAD_ACTIVITY
    FROM ACTIVITIES
    WHERE ACTIVITY_DESCRIPTION IN ('RUSU','RDSU', 'Road Rig')
)

, ACTIVITY_CHECKS AS (
    /* LOGIC FOR SUGGESTING POSSIBLE SUGGESTED CORRECTIONS WHERE WE THINK SOMETHING WAS MISLABELED IN KEYVIEW*/
    SELECT 
        A.*,
        CASE 
                -- Check if this is the first activity is Rig down followed by a Rig down, it is probably supposed to be a Rig up
                WHEN LAG_ACTIVITY IS NULL AND ACTIVITY = 'RDSU' AND  LEAD_ACTIVITY = 'RDSU' then 'RUSU' 
                -- Check if this is the first Rig down where there are multiple rig downs without a Rig Up between them, these are still billable hours
                WHEN LAG_ACTIVITY IS NOT NULL AND ACTIVITY = 'RDSU' AND LEAD_ACTIVITY = 'RDSU' THEN ACTIVITY + '-1'
                -- Check if there is a Rig down service unit without a rig up service unit or following a Road rig
                WHEN LAG_ACTIVITY = 'Road Rig' and ACTIVITY = 'RDSU' THEN 'RUSU'
                -- Check if this may be an error Road rig because it does not lead the activities or happens between a Rig up service unit and Rig down service unit
                WHEN ACTIVITY = 'Road Rig' and ACTIVITY_ERROR = 'possible error' then ACTIVITY + '-1'
                ELSE NULL END AS ACTIVITY_CORRECTION
    
    FROM (
        /* LOGIC FOR ERROR FLAGGING */
        SELECT
            JOBNUMBER,
            ACTIVITY_NUMBER,
            LAG_ACTIVITY,
            ACTIVITY,
            LEAD_ACTIVITY,
            CASE 
                WHEN LAG_ACTIVITY IS NULL AND ACTIVITY = 'RDSU' THEN 'possible error'
                WHEN LAG_ACTIVITY = 'RDSU' AND ACTIVITY = 'RUSU' AND LEAD_ACTIVITY = 'Road Rig' THEN 'possible error'
                WHEN LAG_ACTIVITY = 'Road rig' and ACTIVITY = 'RDSU' then 'possible error'
                WHEN LAG_ACTIVITY = 'RUSU' and ACTIVITY = 'Road Rig' and LEAD_ACTIVITY = 'RDSU' then 'possible error'
                WHEN LAG_ACTIVITY = 'RUSU' and ACTIVITY = 'Road Rig' then 'possible error'
                else NULL END AS ACTIVITY_ERROR
        FROM LAG_LEAD_ACTIVITIES) A
)

, DATASET AS (
    /* ADDING THE STEP TO RECOMBINE WHAT WE HAVE SO FAR TO BREAK UP THE SQL FOR EASIER DEBUGGING AND FUTURE CHANGES */
    SELECT 
        A.CUSTOMER,
        a.CUSTOMER_DIVISION,
        A.JOBNUMBER,
        A.RIG,
        A.WELL_NAME,
        A.WORKINGDEPTH,
        A.WELLBORECONFIG,
        A.WORKTYPE,
        A.JOBTYPE,
        A.JOBSTARTTIME,
        A.JOBENDTIME,
        U.RUSU,
        D.RDSU,
        CASE WHEN U.RUSU IS NULL THEN 'No Rig Up' ELSE 'Rig Up' END AS RIG_UP_FLAG,
        A.ACTIVITY_NUMBER,
        A.ACTIVITYSTARTTIME,
        A.ACTIVITYENDTIME, 
        A.ACTIVITYDESCRIPTION AS ACTIVITYDESCRIPTION_ORIGINAL,
        A.ACTIVITY_DESCRIPTION AS ACTIVITY_ABBR_ORIGINAL,
        CASE WHEN C.ACTIVITY_CORRECTION IS NULL THEN '' ELSE C.ACTIVITY_CORRECTION END AS ACTIVITY_CORRECTION,
       /* REVISED THE ACTIVITY DESC AND ABBR FIELDS USING LOGIC OF ROADRIG BEFORE RUSU AND AFTER RDSU, AND CORRECTIONS */
        CASE 
             /* IDENTIFIY THE ROAD RIGS - ANYTHING BEFORE THE FIRST RUSU */
            WHEN (A.ACTIVITYSTARTTIME < U.RUSU OR A.ACTIVITYENDTIME > RDSU) THEN 'Road rig'
            /* PULL IN ACTIVITY DESCRIPTION PROPOSED CORRECTIONS */
            WHEN C.ACTIVITY_CORRECTION = 'RUSU' THEN 'Rig up service unit' 
            WHEN C.ACTIVITY_CORRECTION = 'RDSU' THEN 'Rig down service unit'
            WHEN C.ACTIVITY_CORRECTION IS NOT NULL THEN C.ACTIVITY_CORRECTION
            ELSE A.ACTIVITYDESCRIPTION END AS ACTIVITYDESCRIPTION,
        CASE  
             /* IDENTIFIY THE ROAD RIGS - ANYTHING BEFORE THE FIRST RUSU */
            WHEN (A.ACTIVITYSTARTTIME < U.RUSU OR A.ACTIVITYENDTIME > RDSU) THEN 'Road rig'
            /* PULL IN ACTIVITY DESCRIPTION PROPOSED CORRECTIONS */
            WHEN C.ACTIVITY_CORRECTION IS NOT NULL THEN C.ACTIVITY_CORRECTION ELSE A.ACTIVITY_DESCRIPTION END AS ACTIVITY_ABBR,
        CASE WHEN C.ACTIVITY_ERROR IS NULL THEN '' ELSE C.ACTIVITY_ERROR END AS ACTIVITY_ERROR,
        A.DURATIONMINUTES,
        A.DURATIONMINUTES/60 AS DURATIONHOURS
    FROM ACTIVITIES A 
    LEFT JOIN RIGUP U ON (A.JOBNUMBER = U.JOBNUMBER)
    LEFT JOIN RIGDOWN D ON (A.JOBNUMBER = D.JOBNUMBER)
    LEFT JOIN ACTIVITY_CHECKS C ON (A.JOBNUMBER = C.JOBNUMBER AND A.ACTIVITY_NUMBER = C.ACTIVITY_NUMBER)
)

SELECT * FROM DATASET
;
GO

