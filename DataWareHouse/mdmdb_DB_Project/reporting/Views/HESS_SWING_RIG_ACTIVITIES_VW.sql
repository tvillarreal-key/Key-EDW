CREATE VIEW [reporting].[HESS_SWING_RIG_ACTIVITIES_VW] AS 

WITH __SWINGRIGS__ AS (
    /* FIND THE RIG AND JOB NUMBER FOR THE SWING RIGS AND/OR THE SERVICE RIG THAT REPLACED THE SWING RIG */
    SELECT 
        FORMAT(CONVERT(INT, ASSET_ID),'0000000') AS RIG,
        JOB_ID AS JOBNUMBER,
        TRIM(
            LEFT(CUSTOMER_JOB_ID, CHARINDEX('-',CUSTOMER_JOB_ID, 1)-1)
            ) AS SWING_RIG,
        TRIM(
            RIGHT(CUSTOMER_JOB_ID, LEN(CUSTOMER_JOB_ID)-CHARINDEX('-',CUSTOMER_JOB_ID, 1))
            ) AS SWING_JOBNUMBER
    FROM DBO.KEYVIEW_JOB 
    WHERE CU_ORG_UNIT LIKE '%Hess%'  AND CUSTOMER_JOB_ID LIKE '%-%' 
)

, __ACTIVITIES__ AS (
    /* GET ALL HESS ACTIVITIES */
    SELECT
        A.JOBNUMBER,
        FORMAT(CONVERT(INT,A.RIG), '0000000') AS RIG,
        S.SWING_RIG AS ORIGINAL_RIG,
        S.SWING_JOBNUMBER AS ORIGINAL_JOBNUMBER,
        WELL_NAME,
        WORKINGDEPTH,
        WELLBORECONFIG,
        WORKTYPE,
        JOBTYPE,
        JOBSTARTTIME,
        CASE 
            WHEN CONVERT(TIME,A.JOBENDTIME) = '00:00:00' THEN DATEADD(S,-1,A.JOBENDTIME) -- JOB CROSS MIDNIGHT, NEED TO KEEP IT IN THE SAME DAY - THIS IS REALLY FOR JOBS ENDING LAST DAY OF MONTH
            ELSE A.JOBENDTIME END AS JOBENDTIME,
        CASE 
            WHEN CONVERT(TIME,A.JOBENDTIME) = '00:00:00' THEN FORMAT(DATEADD(S,-1,A.JOBENDTIME), 'MM-yyyy') -- JOB CROSS MIDNIGHT, NEED TO KEEP IT IN THE SAME DAY - THIS IS REALLY FOR JOBS ENDING LAST DAY OF MONTH
            ELSE FORMAT(A.JOBENDTIME, 'MM-yyyy') END AS JOBENDMONTH,
        CASE 
            WHEN CONVERT(TIME,A.JOBENDTIME) = '00:00:00' THEN EOMONTH(DATEADD(S,-1, A.JOBENDTIME)) -- JOB CROSS MIDNIGHT, NEED TO KEEP IT IN THE SAME DAY - THIS IS REALLY FOR JOBS ENDING LAST DAY OF MONTH
            ELSE EOMONTH(A.JOBENDTIME) END AS JOBENDMONTHORDER,
        CASE 
            WHEN CONVERT(TIME,A.JOBENDTIME) = '00:00:00' THEN CONVERT(DATE, DATEADD(S,-1,A.JOBENDTIME)) -- JOB CROSS MIDNIGHT, NEED TO KEEP IT IN THE SAME DAY - THIS IS REALLY FOR JOBS ENDING LAST DAY OF MONTH
            ELSE CONVERT(DATE, A.JOBENDTIME) END AS JOBENDDATE,
        ACTIVITY_NUMBER,
        ACTIVITY_ID,
        ACTIVITYDESCRIPTION,
        ACTIVITY_DESCRIPTION,
        ACTIVITYSTARTTIME,
        CASE 
            WHEN CONVERT(TIME,ACTIVITYENDTIME) = '00:00:00' THEN DATEADD(S,-1, ACTIVITYENDTIME) --ACTIVITY CROSSED MIDNIGHT, NEED TO KEEP IN SAME DAY
            ELSE ACTIVITYENDTIME END AS ACTIVITYENDTIME, 
        CASE 
            WHEN CONVERT(TIME,ACTIVITYENDTIME) = '00:00:00' THEN FORMAT(DATEADD(S,-1, ACTIVITYENDTIME), 'MM-yyyy') --ACTIVITY CROSSED MIDNIGHT, NEED TO KEEP IN SAME DAY
            ELSE FORMAT(ACTIVITYENDTIME, 'MM-yyyy') END  AS ACTIVITYENDMONTH,
        CASE 
            WHEN CONVERT(TIME,ACTIVITYENDTIME) = '00:00:00' THEN EOMONTH(DATEADD(S,-1, ACTIVITYENDTIME)) --ACTIVITY CROSSED MIDNIGHT, NEED TO KEEP IN SAME DAY
            ELSE EOMONTH(ACTIVITYENDTIME) END AS ACTIVITYENDMONTHORDER ,
        CASE 
            WHEN CONVERT(TIME,ACTIVITYENDTIME) = '00:00:00' THEN CONVERT(DATE,DATEADD(S,-1, ACTIVITYENDTIME)) --ACTIVITY CROSSED MIDNIGHT, NEED TO KEEP IN SAME DAY
            ELSE CONVERT(DATE, (ACTIVITYENDTIME)) END AS ACTIVITYENDDATE ,
        DURATIONMINUTES
    FROM DBO.KEYVIEW_ACTIVITIES2 AS A 
    INNER JOIN __SWINGRIGS__ AS S ON (A.JOBNUMBER = S.JOBNUMBER)
    WHERE CUSTOMERORGUNIT LIKE '%Hess%' AND (A.JOBENDTIME > EOMONTH(DATEADD(M,-14,GETDATE())) OR A.JOBENDTIME IS NULL)
)

/* CALCULATE THE FIRST RIG UP AND LAST RIG DOWN PER JOB */
, __RIGUP__ AS (
    SELECT 
        JOBNUMBER,
        MIN(ACTIVITYSTARTTIME) AS RUSU,
        MIN(ACTIVITYENDTIME) AS RUSU_ENDTIME
    FROM __ACTIVITIES__
    WHERE ACTIVITY_DESCRIPTION = 'RUSU'
    GROUP BY JOBNUMBER
)

, __RIGDOWN__ AS (
    SELECT 
        JOBNUMBER,
        MAX(ACTIVITYENDTIME) AS RDSU
    FROM __ACTIVITIES__
    WHERE ACTIVITY_DESCRIPTION = 'RDSU'
    GROUP BY JOBNUMBER

)

, __RIGLIST__ AS (
    /* GET THE HESS RIG LIST WITH THE RIGTYPES/ SUBTYPES BY OPERATION DATE */
    SELECT 
        RIG,
        OPDATE,
        CASE 
            WHEN RIG ='0086063' AND (OPDATE < '2024-06-14' OR OPDATE > '2024.12.14') THEN '24 Hour' 
            WHEN RIG = '0086063' AND (OPDATE >= '2024.06.14' AND OPDATE < '2024.12.15') THEN 'Daylight' 
            ELSE RIGTYPE END AS RIGTYPE,
        CASE 
            WHEN RIG = '0086063' AND (OPDATE < '2024.06.14' OR OPDATE > '2024.12.14')  THEN '24-Hour' 
            WHEN RIG = '0086063' AND (OPDATE >= '2024.06.14' AND OPDATE < '2024.12.15') THEN '7-Day' 
            ELSE RIGSUBTYPE END AS RIGSUBTYPE
        FROM REPORTING.HESS_RIG_LIST_HIST
)

, __LAG_LEAD_ACTIVITIES__ AS (
    /* LAG LOOKS BACK AND LEAD LOOKS FORWARD, THIS ALLOWS US TO SEE IF A JOB IS MISISNG A RIG UP, OR IF A RIG UP AND RIG DOWN ARE IN THE WRONG ORDER */
    SELECT 
        JOBNUMBER,
        ACTIVITY_NUMBER,
        ACTIVITY_ID,
        ACTIVITYSTARTTIME,
        LAG(ACTIVITY_DESCRIPTION, 1) OVER (PARTITION BY JOBNUMBER ORDER BY ACTIVITYSTARTTIME) AS LAG_ACTIVITY,
        ACTIVITY_DESCRIPTION AS ACTIVITY,
        LEAD(ACTIVITY_DESCRIPTION, 1) OVER (PARTITION BY JOBNUMBER ORDER BY ACTIVITYSTARTTIME) AS LEAD_ACTIVITY
    FROM __ACTIVITIES__
    WHERE ACTIVITY_DESCRIPTION IN ('RUSU','RDSU', 'Road Rig')
)

, __ACTIVITY_CHECKS__ AS (
    /* LOGIC FOR SUGGESTING POSSIBLE SUGGESTED CORRECTIONS WHERE WE THINK SOMETHING WAS MISLABELED IN KEYVIEW*/
    SELECT 
        A.*,
        CASE 
                -- Check if this is the first activity is Rig down followed by a Rig down, it is probably supposed to be a Rig up
                WHEN LAG_ACTIVITY IS NULL AND ACTIVITY = 'RDSU' AND  LEAD_ACTIVITY = 'RDSU' then 'RUSU' 
                -- Check if this is the first Rig down where there are multiple rig downs without a Rig Up between them, these are still billable hours
                WHEN LAG_ACTIVITY IS NOT NULL AND ACTIVITY = 'RDSU' AND LEAD_ACTIVITY = 'RDSU' THEN ACTIVITY + '-1'
                -- Check if there is a Rig down service unit without a rig up service unit or following a Road rig
                WHEN LAG_ACTIVITY = 'Road Rig' and ACTIVITY = 'RDSU' THEN 'RUSU'
                -- Check if this may be an error Road rig because it does not lead the activities or happens between a Rig up service unit and Rig down service unit
                WHEN ACTIVITY = 'Road Rig' and ACTIVITY_ERROR = 'possible error' then ACTIVITY + '-1'
                ELSE NULL END AS ACTIVITY_CORRECTION
    
    FROM (
        /* LOGIC FOR ERROR FLAGGING */
        SELECT
            JOBNUMBER,
            ACTIVITY_NUMBER,
            LAG_ACTIVITY,
            ACTIVITY,
            LEAD_ACTIVITY,
            CASE 
                WHEN LAG_ACTIVITY IS NULL AND ACTIVITY = 'RDSU' THEN 'possible error'
                WHEN LAG_ACTIVITY = 'RDSU' AND ACTIVITY = 'RUSU' AND LEAD_ACTIVITY = 'Road Rig' THEN 'possible error'
                WHEN LAG_ACTIVITY = 'Road rig' and ACTIVITY = 'RDSU' then 'possible error'
                WHEN LAG_ACTIVITY = 'RUSU' and ACTIVITY = 'Road Rig' and LEAD_ACTIVITY = 'RDSU' then 'possible error'
                WHEN LAG_ACTIVITY = 'RUSU' and ACTIVITY = 'Road Rig' then 'possible error'
                else NULL END AS ACTIVITY_ERROR
        FROM __LAG_LEAD_ACTIVITIES__) A
)

, __DATASET__ AS (
    /* ADDING THE STEP TO RECOMBINE WHAT WE HAVE SO FAR TO BREAK UP THE SQL FOR EASIER DEBUGGING AND FUTURE CHANGES */
    SELECT 
        A.JOBNUMBER,
        A.RIG,
        A.ORIGINAL_RIG,
        A.ORIGINAL_JOBNUMBER,
        CASE 
            WHEN A.JOBNUMBER = A.ORIGINAL_JOBNUMBER THEN 'NA'
            ELSE A.ORIGINAL_JOBNUMBER END AS JOB_NUMBER_DIFF,
        R.RIGTYPE,
        R.RIGSUBTYPE,
        A.WELL_NAME,
        A.WORKINGDEPTH,
        A.WELLBORECONFIG,
        A.WORKTYPE,
        A.JOBTYPE,
        A.JOBSTARTTIME,
        A.JOBENDTIME,
        U.RUSU,
        U.RUSU_ENDTIME,
        D.RDSU,
        CASE WHEN U.RUSU IS NULL THEN 'No Rig Up' ELSE 'Rig Up' END AS RIG_UP_FLAG,
        A.ACTIVITY_NUMBER,
        A.ACTIVITY_ID,
        A.ACTIVITYSTARTTIME,
        A.ACTIVITYENDTIME, 
        A.ACTIVITYDESCRIPTION AS ACTIVITYDESCRIPTION_ORIGINAL,
        A.ACTIVITY_DESCRIPTION AS ACTIVITY_ABBR_ORIGINAL,
        CASE WHEN C.ACTIVITY_CORRECTION IS NULL THEN '' ELSE C.ACTIVITY_CORRECTION END AS ACTIVITY_CORRECTION,
       /* REVISED THE ACTIVITY DESC AND ABBR FIELDS USING LOGIC OF ROADRIG BEFORE RUSU AND AFTER RDSU, AND CORRECTIONS */
        CASE 
             /* IDENTIFIY THE ROAD RIGS - ANYTHING BEFORE THE FIRST RUSU */
            WHEN (A.ACTIVITYSTARTTIME < U.RUSU OR A.ACTIVITYENDTIME > RDSU) THEN 'Road rig'
            /* PULL IN ACTIVITY DESCRIPTION PROPOSED CORRECTIONS */
            WHEN C.ACTIVITY_CORRECTION = 'RUSU' THEN 'Rig up service unit' 
            WHEN C.ACTIVITY_CORRECTION = 'RDSU' THEN 'Rig down service unit'
            WHEN C.ACTIVITY_CORRECTION IS NOT NULL THEN C.ACTIVITY_CORRECTION
            ELSE A.ACTIVITYDESCRIPTION END AS ACTIVITYDESCRIPTION,
        CASE  
             /* IDENTIFIY THE ROAD RIGS - ANYTHING BEFORE THE FIRST RUSU */
            WHEN (A.ACTIVITYSTARTTIME < U.RUSU OR A.ACTIVITYENDTIME > RDSU) THEN 'Road rig'
            /* PULL IN ACTIVITY DESCRIPTION PROPOSED CORRECTIONS */
            WHEN C.ACTIVITY_CORRECTION IS NOT NULL THEN C.ACTIVITY_CORRECTION ELSE A.ACTIVITY_DESCRIPTION END AS ACTIVITY_ABBR,
        CASE WHEN C.ACTIVITY_ERROR IS NULL THEN '' ELSE C.ACTIVITY_ERROR END AS ACTIVITY_ERROR,
        A.DURATIONMINUTES,
        A.DURATIONMINUTES/60 AS DURATIONHOURS,
        A.JOBENDMONTH,
        A.JOBENDMONTHORDER,
        A.ACTIVITYENDDATE,
        A.ACTIVITYENDMONTH,
        A.ACTIVITYENDMONTHORDER 
    FROM __ACTIVITIES__ A 
    LEFT JOIN __RIGUP__ U ON (A.JOBNUMBER = U.JOBNUMBER)
    LEFT JOIN __RIGDOWN__ D ON (A.JOBNUMBER = D.JOBNUMBER)
    LEFT JOIN __ACTIVITY_CHECKS__ C ON (A.JOBNUMBER = C.JOBNUMBER AND A.ACTIVITY_NUMBER = C.ACTIVITY_NUMBER)
    LEFT JOIN __RIGLIST__ R ON (A.ORIGINAL_RIG = R.RIG AND CONVERT(DATE, A.ACTIVITYENDTIME) = R.OPDATE)
)

SELECT * FROM __DATASET__
;
GO

