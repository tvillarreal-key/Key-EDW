CREATE VIEW [hr_reporting].[ADP_TRANSACTIONS_VW] AS 

/* ----------------------- BEGIN CODE BLOCK -------------------*/

WITH __BASE_ITEMS__ AS (
    /* GET CORE ACTIONS FROM ADP TABLE TO FORM A FILTER FOR ONLY EVALUATING EMPLOYEES THAT WERE ACTIVE IN 2023 FORWARD */
    SELECT 
        EMPLOYEEID AS EIN,
        EFFECTIVEDATE,
        OrginalDateOfHire,
        [ACTION] AS HR_ACTION,
        EMPLOYEESTATUS,
        ROW_NUMBER() OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE ASC, EMPLOYEESTATUS ASC) AS ROWNUMBER 
    FROM DBO.ADP_TRANSACTIONS 
    WHERE LEFT(EMPLOYEEID,4)  <> '9999' -- THE IS DESIGNATED FOR CONTRACTORS WHO NEED TO ACCESS OUR COMPANY SYSTEMS WITH AN EIN 
)

, __ACTIVE_TERM__ AS (
    /* CREATE A START AND END DATE FOR THE CORE ACTIVE/ TERM STATUS FIELDS */
    SELECT 
        EIN,
        CASE 
            WHEN ROWNUMBER = 1 THEN ORGINALDATEOFHIRE 
            WHEN ROWNUMBER <> 1 THEN EFFECTIVEDATE 
            END AS START_DT,
        CASE    
            WHEN LEAD(EFFECTIVEDATE) OVER (PARTITION BY EIN ORDER BY ROWNUMBER) IS NULL THEN '9999-12-31'
            ELSE LEAD(EFFECTIVEDATE) OVER (PARTITION BY EIN ORDER BY ROWNUMBER) 
            END AS END_DT,
        EMPLOYEESTATUS
    FROM __BASE_ITEMS__
)

, __FILTER__ AS (
    /* GET A LIST OF EIN'S THAT WERE ACTIVELY EMPLOYEED WITH KEY ENERGY IN 2023 */
    SELECT DISTINCT 
        EIN
    FROM __ACTIVE_TERM__ 
    WHERE EMPLOYEESTATUS IN ('A','L') AND END_DT > '2022-12-31'
)

, __ADP__ AS (
    SELECT 
        A.*,
        ROW_NUMBER() OVER (PARTITION BY EIN ORDER BY EFFECTIVEDATE ASC, ACTION_STATUS_ORDER ASC) AS ROWNUMBER 
    FROM (
        SELECT 
            EMPLOYEEID AS EIN,
            REPORTSTOMANGERID AS MGR_ID,
            [ACTION]AS HR_ACTION,
            DEPT_DISTRICTID,
            EFFECTIVEDATE,
            EMPLOYEESTATUS,
            CASE 
                WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) AND 
                    EMPLOYEESTATUS = 'A' AND LEAD(EMPLOYEESTATUS) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) = 'L' AND 
                    [ACTION] = 'RFL' 
                    THEN 1 -- NEED TO ORDER THE 'L' BEFORE THE 'A' WHEN THEY APPEAR IN SAME DAY AND SOMEONE RETURNS FROM LEAVE 
                WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) AND 
                    EMPLOYEESTATUS = 'T' AND LEAD(EMPLOYEESTATUS) OVER (PARTITION BY EMPLOYEEID ORDER BY EFFECTIVEDATE) = 'A' 
                    THEN 2 --GENERALLY YOU ARE NOT ACTIVE AFTER YOU TERM IN THE SAME DAY
                ELSE 0 -- ORDER BY EFFECTIVE DATE WORKS HERE
                END AS ACTION_STATUS_ORDER,
            FULL_PART,
            HOURLY_SALARY,
            INSERTBATCHNUM,
            INSERTDATE,
            JOBTITLE,
            LASTDATEOFHIRE AS LAST_HIRE_DT,
            LEVEL1,
            LEVEL2,
            LOCATIONCODE,
            MARKETPLACE,
            ORGINALDATEOFHIRE AS ORIGINAL_HIRE_DT,
            PAYGROUP,
            REASONCODE,
            REASONDESCRIPTION,
            REG_TEMP,
            VOL_INVOL,
            WORKLOCATION,
            WORKLOCATIONDESC
        FROM __FILTER__ E 
        LEFT JOIN DBO.ADP_TRANSACTIONS A ON (E.EIN = A.EMPLOYEEID)
        ) A 
    
)

, __ADD_BEGIN_END_DATES__ AS (
    /* ADD BEGINNING AND ENDING DATES FOR EACH CHANGE IN THE ADP TABLE */
    SELECT 
        EIN,
        /* BEGINING DATES */
        CASE 
            WHEN ROWNUMBER = 1 THEN ORIGINAL_HIRE_DT
            ELSE EFFECTIVEDATE 
            END AS START_DT, 
        CASE 
            WHEN HR_ACTION = 'TER' THEN EFFECTIVEDATE
            WHEN HR_ACTION <> 'TER' AND ROWNUMBER = MAX(ROWNUMBER) OVER (PARTITION BY EIN) THEN '9999-12-31'
            WHEN EFFECTIVEDATE = LEAD(EFFECTIVEDATE)  OVER (PARTITION BY EIN ORDER BY ROWNUMBER) THEN EFFECTIVEDATE 
            ELSE DATEADD(D, -1, LEAD(EFFECTIVEDATE)  OVER (PARTITION BY EIN ORDER BY ROWNUMBER)) --BACK OFF ONE DAY SO THAT END DATES DONT CONFLICT WITH START DATES
            END AS END_DT,
        HR_ACTION,
        REASONCODE,
        REASONDESCRIPTION,
        ROWNUMBER 
    FROM __ADP__ 
)

, __LOCATIONS__ AS (
    SELECT DISTINCT 
        MKTP_CODE,
        MKTP_NAME,
        LOCO_CODE,
        LOCO_NAME,
        LOCA_CODE,
        LOCA_NAME,
        LVL1_CODE,
        LVL1_NAME,
        LVL2_CODE,
        LVL2_NAME
    FROM DBO.LOCO_HIERARCHY
)

, __DIST__ AS (
    SELECT DISTINCT 
        DIST_CODE,
        DIST_NAME
    FROM DBO.LOCO_HIERARCHY
)

, __DATASET__ AS (
    SELECT 
        B.EIN,
        B.START_DT,
        B.END_DT, 
        A.MGR_ID,
        B.HR_ACTION,
        B.REASONCODE,
        B.REASONDESCRIPTION,
        A.EFFECTIVEDATE,
        A.ORIGINAL_HIRE_DT,
        A.LAST_HIRE_DT,
        CASE 
            WHEN (A.HR_ACTION = 'TER' AND A.REASONCODE = 'DEA') THEN 'D' ELSE A.EMPLOYEESTATUS END AS EMPLOYEESTATUS,
        CASE
            WHEN B.START_DT = B.END_DT AND 
                    ((B.START_DT = LEAD(B.START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER)) OR 
                    (B.START_DT = LAG(B.START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER))) THEN 0 -- THESE WILL BE ACCOUNT FOR IN ANOTHER ROW 
            WHEN (A.EMPLOYEESTATUS IN ('A','L') AND B.END_DT = '9999-12-31') THEN DATEDIFF(D, B.START_DT, GETDATE()) + 1 -- CURRENT EMPLOYEE 
            WHEN (A.EMPLOYEESTATUS IN ('A','L') AND B.END_DT <> '9999-12-31') THEN DATEDIFF(D, B.START_DT, B.END_DT) + 1 -- WAS ACTIVE FOR THIS ADP TRANSACTION
            ELSE 0 -- NOT MARKED AS AN ACTIVE EMPLOYEE ROW 
            END AS KEY_DAYS_EMPLOYED, 
        A.FULL_PART,
        A.HOURLY_SALARY,
        A.JOBTITLE,
        A.PAYGROUP,
        A.REG_TEMP,
        A.VOL_INVOL,
        /* LOCATION INFORMATION */
        A.DEPT_DISTRICTID,
        D.DIST_NAME,
        A.LOCATIONCODE,
        A.LEVEL1,
        A.LEVEL2,
        L.MKTP_NAME,
        L.LOCO_NAME,
        L.LOCA_NAME,
        L.LVL1_NAME,
        L.LVL2_NAME,
        B.ROWNUMBER AS EMP_UPDATE_CNT, -- THIS WILL HELP TO SHOW ADP UPDATES GROUPED BY EMPLOYEE
        CASE 
            WHEN B.START_DT = B.END_DT AND 
                (B.START_DT = LEAD(B.START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER) OR (B.START_DT = LAG(B.START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER))) THEN 100 -- THESE WILL BE COUNTED IN THE ROW THAT DOESNT END ON THE SAME DAY 
            ELSE 1
            END AS DAILY_UPDATE_CNT, -- THIS GROUPING WILL HELP TO REMOVE ANY DUPLICATE COUNTS FOR DAYS EMPLOYED
        CASE 
            WHEN (EMPLOYEESTATUS = 'A' AND 
                LEAD(EMPLOYEESTATUS) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER) <> 'A') AND 
                (FORMAT(END_DT, 'MM-yyyy') = FORMAT(LEAD(START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER), 'MM-yyyy')) THEN 1 
            ELSE 0 
            END AS ACT_CHNG_SAME_MONTH_CHECK,
        CASE 
            WHEN EMPLOYEESTATUS = 'L' AND 
                LEAD(EMPLOYEESTATUS) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER) <> 'L' AND 
                FORMAT(END_DT, 'MM-yyyy') = FORMAT(LEAD(START_DT) OVER (PARTITION BY B.EIN ORDER BY B.ROWNUMBER), 'MM-yyyy') THEN 1 
            ELSE 0 
            END AS LOA_CHNG_SAME_MONTH_CHECK
    FROM __ADD_BEGIN_END_DATES__ B 
    LEFT JOIN __ADP__ A ON B.EIN = A.EIN AND B.ROWNUMBER = A.ROWNUMBER 
    LEFT JOIN __LOCATIONS__ L ON A.LOCATIONCODE = L.LOCA_CODE AND A.LEVEL1 = L.LVL1_CODE AND A.LEVEL2 = L.LVL2_CODE
    LEFT JOIN __DIST__ D ON A.DEPT_DISTRICTID = D.DIST_CODE

)

SELECT * FROM __DATASET__
GO

